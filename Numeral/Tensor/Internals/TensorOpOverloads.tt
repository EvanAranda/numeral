<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Tensor.dsl" #>

using System;
using System.Buffers;
using System.Numerics;
using System.Runtime.CompilerServices;

using Numeral.Internals;

namespace Numeral
{
    public abstract partial class Tensor<T>
    {
<#
foreach (var method in DSL.BinaryMethods)
{
    if (!method.HasOp) continue;
    var r = method.IsComp ? "bool" : "T";
#>
        public static Tensor<<#= r #>> operator <#= method.Op #>(Tensor<T> x, Tensor<T> y) => Dispatcher.Call(x.Core.Basic.<#= method.Name #>, x, y);
        public static Tensor<<#= r #>> operator <#= method.Op #>(Tensor<T> x, T y) => Dispatcher.Call(x.Core.Basic.<#= method.Name #>, x, (ScalarTensor<T>)y);
        public static Tensor<<#= r #>> operator <#= method.Op #>(T x, Tensor<T> y) => Dispatcher.Call(y.Core.Basic.<#= method.Name #>, (ScalarTensor<T>)x, y);
<#
} // end binary methods
#>
<#
foreach (var method in DSL.UnaryMethods)
{
    if (!method.HasOp) continue;
#>
        public static Tensor<T> operator <#= method.Op #>(Tensor<T> x) => Dispatcher.Call(x.Core.Basic.<#= method.Name #>, x);
<#
} // end unary methods
#>
    }
}