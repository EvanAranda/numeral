
using System;
using System.Buffers;
using System.Numerics;
using System.Runtime.CompilerServices;

using Numeral.Internals;

namespace Numeral
{
    public static partial class Tensor
    {
        public static Tensor<T> Add<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Add.Call(x, y);
        public static Tensor<T> Add<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Add.Call(x, y, result);
        public static Tensor<T> Add<T>(this Tensor<T> x, T y) => x.Core.Basic.Add.Call(x, (Scalar<T>)y);
        public static Tensor<T> Add<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Add.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Add<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Add.Call((Scalar<T>)x, y, result);
        public static Tensor<T> AddInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Add.Call(x, y, x);
        public static Tensor<T> AddInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Add.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Add<T>(T x, Tensor<T> y) => y.Core.Basic.Add.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Subtract<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Subtract.Call(x, y);
        public static Tensor<T> Subtract<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Subtract.Call(x, y, result);
        public static Tensor<T> Subtract<T>(this Tensor<T> x, T y) => x.Core.Basic.Subtract.Call(x, (Scalar<T>)y);
        public static Tensor<T> Subtract<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Subtract.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Subtract<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Subtract.Call((Scalar<T>)x, y, result);
        public static Tensor<T> SubtractInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Subtract.Call(x, y, x);
        public static Tensor<T> SubtractInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Subtract.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Subtract<T>(T x, Tensor<T> y) => y.Core.Basic.Subtract.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Multiply<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Multiply.Call(x, y);
        public static Tensor<T> Multiply<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Multiply.Call(x, y, result);
        public static Tensor<T> Multiply<T>(this Tensor<T> x, T y) => x.Core.Basic.Multiply.Call(x, (Scalar<T>)y);
        public static Tensor<T> Multiply<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Multiply.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Multiply<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Multiply.Call((Scalar<T>)x, y, result);
        public static Tensor<T> MultiplyInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Multiply.Call(x, y, x);
        public static Tensor<T> MultiplyInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Multiply.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Multiply<T>(T x, Tensor<T> y) => y.Core.Basic.Multiply.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Divide<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Divide.Call(x, y);
        public static Tensor<T> Divide<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Divide.Call(x, y, result);
        public static Tensor<T> Divide<T>(this Tensor<T> x, T y) => x.Core.Basic.Divide.Call(x, (Scalar<T>)y);
        public static Tensor<T> Divide<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Divide.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Divide<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Divide.Call((Scalar<T>)x, y, result);
        public static Tensor<T> DivideInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Divide.Call(x, y, x);
        public static Tensor<T> DivideInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Divide.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Divide<T>(T x, Tensor<T> y) => y.Core.Basic.Divide.Call((Scalar<T>)x, y, y);
        public static Tensor<T> BitAnd<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.BitAnd.Call(x, y);
        public static Tensor<T> BitAnd<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.BitAnd.Call(x, y, result);
        public static Tensor<T> BitAnd<T>(this Tensor<T> x, T y) => x.Core.Basic.BitAnd.Call(x, (Scalar<T>)y);
        public static Tensor<T> BitAnd<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.BitAnd.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> BitAnd<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.BitAnd.Call((Scalar<T>)x, y, result);
        public static Tensor<T> BitAndInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.BitAnd.Call(x, y, x);
        public static Tensor<T> BitAndInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.BitAnd.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> BitAnd<T>(T x, Tensor<T> y) => y.Core.Basic.BitAnd.Call((Scalar<T>)x, y, y);
        public static Tensor<T> BitOr<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.BitOr.Call(x, y);
        public static Tensor<T> BitOr<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.BitOr.Call(x, y, result);
        public static Tensor<T> BitOr<T>(this Tensor<T> x, T y) => x.Core.Basic.BitOr.Call(x, (Scalar<T>)y);
        public static Tensor<T> BitOr<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.BitOr.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> BitOr<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.BitOr.Call((Scalar<T>)x, y, result);
        public static Tensor<T> BitOrInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.BitOr.Call(x, y, x);
        public static Tensor<T> BitOrInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.BitOr.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> BitOr<T>(T x, Tensor<T> y) => y.Core.Basic.BitOr.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Xor<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Xor.Call(x, y);
        public static Tensor<T> Xor<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Xor.Call(x, y, result);
        public static Tensor<T> Xor<T>(this Tensor<T> x, T y) => x.Core.Basic.Xor.Call(x, (Scalar<T>)y);
        public static Tensor<T> Xor<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Xor.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Xor<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Xor.Call((Scalar<T>)x, y, result);
        public static Tensor<T> XorInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Xor.Call(x, y, x);
        public static Tensor<T> XorInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Xor.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Xor<T>(T x, Tensor<T> y) => y.Core.Basic.Xor.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Pow<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Pow.Call(x, y);
        public static Tensor<T> Pow<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Pow.Call(x, y, result);
        public static Tensor<T> Pow<T>(this Tensor<T> x, T y) => x.Core.Basic.Pow.Call(x, (Scalar<T>)y);
        public static Tensor<T> Pow<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Pow.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Pow<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Pow.Call((Scalar<T>)x, y, result);
        public static Tensor<T> PowInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Pow.Call(x, y, x);
        public static Tensor<T> PowInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Pow.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Pow<T>(T x, Tensor<T> y) => y.Core.Basic.Pow.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Mod<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Mod.Call(x, y);
        public static Tensor<T> Mod<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Mod.Call(x, y, result);
        public static Tensor<T> Mod<T>(this Tensor<T> x, T y) => x.Core.Basic.Mod.Call(x, (Scalar<T>)y);
        public static Tensor<T> Mod<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Mod.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Mod<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Mod.Call((Scalar<T>)x, y, result);
        public static Tensor<T> ModInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Mod.Call(x, y, x);
        public static Tensor<T> ModInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Mod.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Mod<T>(T x, Tensor<T> y) => y.Core.Basic.Mod.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Log<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Log.Call(x, y);
        public static Tensor<T> Log<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Log.Call(x, y, result);
        public static Tensor<T> Log<T>(this Tensor<T> x, T y) => x.Core.Basic.Log.Call(x, (Scalar<T>)y);
        public static Tensor<T> Log<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Log.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Log<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Log.Call((Scalar<T>)x, y, result);
        public static Tensor<T> LogInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Log.Call(x, y, x);
        public static Tensor<T> LogInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Log.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Log<T>(T x, Tensor<T> y) => y.Core.Basic.Log.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Maximum<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Maximum.Call(x, y);
        public static Tensor<T> Maximum<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Maximum.Call(x, y, result);
        public static Tensor<T> Maximum<T>(this Tensor<T> x, T y) => x.Core.Basic.Maximum.Call(x, (Scalar<T>)y);
        public static Tensor<T> Maximum<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Maximum.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Maximum<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Maximum.Call((Scalar<T>)x, y, result);
        public static Tensor<T> MaximumInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Maximum.Call(x, y, x);
        public static Tensor<T> MaximumInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Maximum.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Maximum<T>(T x, Tensor<T> y) => y.Core.Basic.Maximum.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Minimum<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Minimum.Call(x, y);
        public static Tensor<T> Minimum<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Minimum.Call(x, y, result);
        public static Tensor<T> Minimum<T>(this Tensor<T> x, T y) => x.Core.Basic.Minimum.Call(x, (Scalar<T>)y);
        public static Tensor<T> Minimum<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Minimum.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Minimum<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Minimum.Call((Scalar<T>)x, y, result);
        public static Tensor<T> MinimumInPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Minimum.Call(x, y, x);
        public static Tensor<T> MinimumInPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Minimum.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Minimum<T>(T x, Tensor<T> y) => y.Core.Basic.Minimum.Call((Scalar<T>)x, y, y);
        public static Tensor<T> Atan2<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Atan2.Call(x, y);
        public static Tensor<T> Atan2<T>(this Tensor<T> x, Tensor<T> y, Tensor<T> result) => x.Core.Basic.Atan2.Call(x, y, result);
        public static Tensor<T> Atan2<T>(this Tensor<T> x, T y) => x.Core.Basic.Atan2.Call(x, (Scalar<T>)y);
        public static Tensor<T> Atan2<T>(this Tensor<T> x, T y, Tensor<T> result) => x.Core.Basic.Atan2.Call(x, (Scalar<T>)y, result);
        public static Tensor<T> Atan2<T>(T x, Tensor<T> y, Tensor<T> result) => y.Core.Basic.Atan2.Call((Scalar<T>)x, y, result);
        public static Tensor<T> Atan2InPlace<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.Atan2.Call(x, y, x);
        public static Tensor<T> Atan2InPlace<T>(this Tensor<T> x, T y) => x.Core.Basic.Atan2.Call(x, (Scalar<T>)y, x);
        public static Tensor<T> Atan2<T>(T x, Tensor<T> y) => y.Core.Basic.Atan2.Call((Scalar<T>)x, y, y);
        public static Tensor<bool> LessThan<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.LessThan.Call(x, y);
        public static Tensor<bool> LessThan<T>(this Tensor<T> x, Tensor<T> y, Tensor<bool> result) => x.Core.Basic.LessThan.Call(x, y, result);
        public static Tensor<bool> LessThan<T>(this Tensor<T> x, T y) => x.Core.Basic.LessThan.Call(x, (Scalar<T>)y);
        public static Tensor<bool> LessThan<T>(this Tensor<T> x, T y, Tensor<bool> result) => x.Core.Basic.LessThan.Call(x, (Scalar<T>)y, result);
        public static Tensor<bool> LessThan<T>(T x, Tensor<T> y, Tensor<bool> result) => y.Core.Basic.LessThan.Call((Scalar<T>)x, y, result);
        public static Tensor<bool> LessThanOrEqual<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.LessThanOrEqual.Call(x, y);
        public static Tensor<bool> LessThanOrEqual<T>(this Tensor<T> x, Tensor<T> y, Tensor<bool> result) => x.Core.Basic.LessThanOrEqual.Call(x, y, result);
        public static Tensor<bool> LessThanOrEqual<T>(this Tensor<T> x, T y) => x.Core.Basic.LessThanOrEqual.Call(x, (Scalar<T>)y);
        public static Tensor<bool> LessThanOrEqual<T>(this Tensor<T> x, T y, Tensor<bool> result) => x.Core.Basic.LessThanOrEqual.Call(x, (Scalar<T>)y, result);
        public static Tensor<bool> LessThanOrEqual<T>(T x, Tensor<T> y, Tensor<bool> result) => y.Core.Basic.LessThanOrEqual.Call((Scalar<T>)x, y, result);
        public static Tensor<bool> GreaterThan<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.GreaterThan.Call(x, y);
        public static Tensor<bool> GreaterThan<T>(this Tensor<T> x, Tensor<T> y, Tensor<bool> result) => x.Core.Basic.GreaterThan.Call(x, y, result);
        public static Tensor<bool> GreaterThan<T>(this Tensor<T> x, T y) => x.Core.Basic.GreaterThan.Call(x, (Scalar<T>)y);
        public static Tensor<bool> GreaterThan<T>(this Tensor<T> x, T y, Tensor<bool> result) => x.Core.Basic.GreaterThan.Call(x, (Scalar<T>)y, result);
        public static Tensor<bool> GreaterThan<T>(T x, Tensor<T> y, Tensor<bool> result) => y.Core.Basic.GreaterThan.Call((Scalar<T>)x, y, result);
        public static Tensor<bool> GreaterThanOrEqual<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.GreaterThanOrEqual.Call(x, y);
        public static Tensor<bool> GreaterThanOrEqual<T>(this Tensor<T> x, Tensor<T> y, Tensor<bool> result) => x.Core.Basic.GreaterThanOrEqual.Call(x, y, result);
        public static Tensor<bool> GreaterThanOrEqual<T>(this Tensor<T> x, T y) => x.Core.Basic.GreaterThanOrEqual.Call(x, (Scalar<T>)y);
        public static Tensor<bool> GreaterThanOrEqual<T>(this Tensor<T> x, T y, Tensor<bool> result) => x.Core.Basic.GreaterThanOrEqual.Call(x, (Scalar<T>)y, result);
        public static Tensor<bool> GreaterThanOrEqual<T>(T x, Tensor<T> y, Tensor<bool> result) => y.Core.Basic.GreaterThanOrEqual.Call((Scalar<T>)x, y, result);
        public static Tensor<bool> ArrayEqual<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.ArrayEqual.Call(x, y);
        public static Tensor<bool> ArrayEqual<T>(this Tensor<T> x, Tensor<T> y, Tensor<bool> result) => x.Core.Basic.ArrayEqual.Call(x, y, result);
        public static Tensor<bool> ArrayEqual<T>(this Tensor<T> x, T y) => x.Core.Basic.ArrayEqual.Call(x, (Scalar<T>)y);
        public static Tensor<bool> ArrayEqual<T>(this Tensor<T> x, T y, Tensor<bool> result) => x.Core.Basic.ArrayEqual.Call(x, (Scalar<T>)y, result);
        public static Tensor<bool> ArrayEqual<T>(T x, Tensor<T> y, Tensor<bool> result) => y.Core.Basic.ArrayEqual.Call((Scalar<T>)x, y, result);
        public static Tensor<bool> ArrayNotEqual<T>(this Tensor<T> x, Tensor<T> y) => x.Core.Basic.ArrayNotEqual.Call(x, y);
        public static Tensor<bool> ArrayNotEqual<T>(this Tensor<T> x, Tensor<T> y, Tensor<bool> result) => x.Core.Basic.ArrayNotEqual.Call(x, y, result);
        public static Tensor<bool> ArrayNotEqual<T>(this Tensor<T> x, T y) => x.Core.Basic.ArrayNotEqual.Call(x, (Scalar<T>)y);
        public static Tensor<bool> ArrayNotEqual<T>(this Tensor<T> x, T y, Tensor<bool> result) => x.Core.Basic.ArrayNotEqual.Call(x, (Scalar<T>)y, result);
        public static Tensor<bool> ArrayNotEqual<T>(T x, Tensor<T> y, Tensor<bool> result) => y.Core.Basic.ArrayNotEqual.Call((Scalar<T>)x, y, result);
        public static Tensor<T> Negate<T>(this Tensor<T> x) => x.Core.Basic.Negate.Call(x);
        public static Tensor<T> Negate<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Negate.Call(x, result);
        public static Tensor<T> NegateInPlace<T>(this Tensor<T> x) => x.Core.Basic.Negate.Call(x, x);
        public static Tensor<T> Abs<T>(this Tensor<T> x) => x.Core.Basic.Abs.Call(x);
        public static Tensor<T> Abs<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Abs.Call(x, result);
        public static Tensor<T> AbsInPlace<T>(this Tensor<T> x) => x.Core.Basic.Abs.Call(x, x);
        public static Tensor<T> BitNot<T>(this Tensor<T> x) => x.Core.Basic.BitNot.Call(x);
        public static Tensor<T> BitNot<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.BitNot.Call(x, result);
        public static Tensor<T> BitNotInPlace<T>(this Tensor<T> x) => x.Core.Basic.BitNot.Call(x, x);
        public static Tensor<T> Floor<T>(this Tensor<T> x) => x.Core.Basic.Floor.Call(x);
        public static Tensor<T> Floor<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Floor.Call(x, result);
        public static Tensor<T> FloorInPlace<T>(this Tensor<T> x) => x.Core.Basic.Floor.Call(x, x);
        public static Tensor<T> Ceiling<T>(this Tensor<T> x) => x.Core.Basic.Ceiling.Call(x);
        public static Tensor<T> Ceiling<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Ceiling.Call(x, result);
        public static Tensor<T> CeilingInPlace<T>(this Tensor<T> x) => x.Core.Basic.Ceiling.Call(x, x);
        public static Tensor<T> Sqrt<T>(this Tensor<T> x) => x.Core.Basic.Sqrt.Call(x);
        public static Tensor<T> Sqrt<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Sqrt.Call(x, result);
        public static Tensor<T> SqrtInPlace<T>(this Tensor<T> x) => x.Core.Basic.Sqrt.Call(x, x);
        public static Tensor<T> Exp<T>(this Tensor<T> x) => x.Core.Basic.Exp.Call(x);
        public static Tensor<T> Exp<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Exp.Call(x, result);
        public static Tensor<T> ExpInPlace<T>(this Tensor<T> x) => x.Core.Basic.Exp.Call(x, x);
        public static Tensor<T> Ln<T>(this Tensor<T> x) => x.Core.Basic.Ln.Call(x);
        public static Tensor<T> Ln<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Ln.Call(x, result);
        public static Tensor<T> LnInPlace<T>(this Tensor<T> x) => x.Core.Basic.Ln.Call(x, x);
        public static Tensor<T> Log10<T>(this Tensor<T> x) => x.Core.Basic.Log10.Call(x);
        public static Tensor<T> Log10<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Log10.Call(x, result);
        public static Tensor<T> Log10InPlace<T>(this Tensor<T> x) => x.Core.Basic.Log10.Call(x, x);
        public static Tensor<T> Sin<T>(this Tensor<T> x) => x.Core.Basic.Sin.Call(x);
        public static Tensor<T> Sin<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Sin.Call(x, result);
        public static Tensor<T> SinInPlace<T>(this Tensor<T> x) => x.Core.Basic.Sin.Call(x, x);
        public static Tensor<T> Cos<T>(this Tensor<T> x) => x.Core.Basic.Cos.Call(x);
        public static Tensor<T> Cos<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Cos.Call(x, result);
        public static Tensor<T> CosInPlace<T>(this Tensor<T> x) => x.Core.Basic.Cos.Call(x, x);
        public static Tensor<T> Tan<T>(this Tensor<T> x) => x.Core.Basic.Tan.Call(x);
        public static Tensor<T> Tan<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Tan.Call(x, result);
        public static Tensor<T> TanInPlace<T>(this Tensor<T> x) => x.Core.Basic.Tan.Call(x, x);
        public static Tensor<T> Asin<T>(this Tensor<T> x) => x.Core.Basic.Asin.Call(x);
        public static Tensor<T> Asin<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Asin.Call(x, result);
        public static Tensor<T> AsinInPlace<T>(this Tensor<T> x) => x.Core.Basic.Asin.Call(x, x);
        public static Tensor<T> Acos<T>(this Tensor<T> x) => x.Core.Basic.Acos.Call(x);
        public static Tensor<T> Acos<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Acos.Call(x, result);
        public static Tensor<T> AcosInPlace<T>(this Tensor<T> x) => x.Core.Basic.Acos.Call(x, x);
        public static Tensor<T> Atan<T>(this Tensor<T> x) => x.Core.Basic.Atan.Call(x);
        public static Tensor<T> Atan<T>(this Tensor<T> x, Tensor<T> result) => x.Core.Basic.Atan.Call(x, result);
        public static Tensor<T> AtanInPlace<T>(this Tensor<T> x) => x.Core.Basic.Atan.Call(x, x);
        public static T Min<T>(this Tensor<T> x) => x.Core.Basic.Min.Call(x);
        public static Tensor<T> Min<T>(this Tensor<T> x, int axis) => x.Core.Basic.Min.Call(x, axis);
        public static Tensor<T> Min<T>(this Tensor<T> x, int axis, Tensor<T> result) => x.Core.Basic.Min.Call(x, result, axis);
        public static T Max<T>(this Tensor<T> x) => x.Core.Basic.Max.Call(x);
        public static Tensor<T> Max<T>(this Tensor<T> x, int axis) => x.Core.Basic.Max.Call(x, axis);
        public static Tensor<T> Max<T>(this Tensor<T> x, int axis, Tensor<T> result) => x.Core.Basic.Max.Call(x, result, axis);
        public static T Sum<T>(this Tensor<T> x) => x.Core.Basic.Sum.Call(x);
        public static Tensor<T> Sum<T>(this Tensor<T> x, int axis) => x.Core.Basic.Sum.Call(x, axis);
        public static Tensor<T> Sum<T>(this Tensor<T> x, int axis, Tensor<T> result) => x.Core.Basic.Sum.Call(x, result, axis);
        public static Tensor<T> Cumsum<T>(this Tensor<T> x, int axis) => x.Core.Basic.Cumsum.Call(x, axis);
        public static Tensor<T> Cumsum<T>(this Tensor<T> x, int axis, Tensor<T> result) => x.Core.Basic.Cumsum.Call(x, result, axis);
        public static Tensor<T> CumsumInPlace<T>(this Tensor<T> x, int axis) => x.Core.Basic.Cumsum.Call(x, x, axis);
        public static Tensor<T> Cumprod<T>(this Tensor<T> x, int axis) => x.Core.Basic.Cumprod.Call(x, axis);
        public static Tensor<T> Cumprod<T>(this Tensor<T> x, int axis, Tensor<T> result) => x.Core.Basic.Cumprod.Call(x, result, axis);
        public static Tensor<T> CumprodInPlace<T>(this Tensor<T> x, int axis) => x.Core.Basic.Cumprod.Call(x, x, axis);
    }
}